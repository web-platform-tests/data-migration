package main

import (
	"bufio"
	"context"
	"flag"
	"fmt"
	"os"
	"strconv"
	"strings"

	"cloud.google.com/go/datastore"

	"github.com/web-platform-tests/wpt.fyi/shared"
)

var (
	dryRun        = flag.Bool("dry-run", true, "Run in dry-run mode")
	projectID     = flag.String("project", "wptdashboard-staging", "Google Cloud project")
	runsFile      = flag.String("runs-file", "staging-runs-without-channels.txt", "Preprocessed runs file")
	validChannels = []string{"stable", "beta", "dev", "canary", "nightly", "preview"}
)

type conditionUnsatisfied struct{}

func (e conditionUnsatisfied) Error() string {
	return "Condition not satisfied"
}

func contains(s []string, e string) bool {
	for _, a := range s {
		if a == e {
			return true
		}
	}
	return false
}

func condition(run *shared.TestRun) bool {
	foundLabel := false
	for _, channel := range validChannels {
		if contains(run.Labels, channel) {
			foundLabel = true
			break
		}
	}
	return !foundLabel
}

func operation(tx *datastore.Transaction, key *datastore.Key, run *shared.TestRun) error {
	originalLabels := run.Labels
	switch run.BrowserName {
	case "chrome":
		if strings.HasSuffix(run.BrowserVersion, "dev") {
			run.Labels = append(run.Labels, "dev")
			break
		}
		return fmt.Errorf("unhandled run: %s (%s %s)", key, run.BrowserName, run.BrowserVersion)
	case "edge":
		// There is only one known unlabelled edge run, which is msedge
		// and should be a preview.
		if contains(run.Labels, "msedge") {
			run.Labels = append(run.Labels, "preview")
			break
		}
		return fmt.Errorf("unhandled run: %s (%s %s)", key, run.BrowserName, run.BrowserVersion)
	case "firefox":
		// Nightly consistently ends in 'a1'
		if strings.HasSuffix(run.BrowserVersion, "a1") {
			run.Labels = append(run.Labels, "nightly")
			break
		}
		return fmt.Errorf("unhandled run: %s (%s %s)", key, run.BrowserName, run.BrowserVersion)
	case "safari":
		if strings.HasSuffix(run.BrowserVersion, "preview") {
			run.Labels = append(run.Labels, "preview")
			break
		}
		// The other Safari runs are stable, though there are no
		// particular checks to enforce that.
		run.Labels = append(run.Labels, "stable")
	default:
		return fmt.Errorf("unhandled run: %s (%s)", key, run.BrowserName)
	}

	if *dryRun {
		fmt.Println("DRY-RUN:", key, " (", run.BrowserName, run.BrowserVersion, "), changing labels from", originalLabels, "to", run.Labels)
		return nil
	}

	_, err := tx.Put(key, run)
	return err
}

func main() {
	flag.Parse()

	// This file was generated by iterating through /api/runs and finding
	// all runs that do not meet the condition.
	file, err := os.Open(*runsFile)
	if err != nil {
		panic(err)
	}
	defer file.Close()

	var runIDs []int64
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		id, err := strconv.ParseInt(scanner.Text(), 10, 0)
		if err != nil {
			panic(err)
		}
		runIDs = append(runIDs, id)
	}

	if err := scanner.Err(); err != nil {
		panic(err)
	}

	ctx := context.Background()

	client, err := datastore.NewClient(ctx, *projectID)
	if err != nil {
		panic(err)
	}

	// Now hit the datastore for each case. We double-check the condition
	// whilst doing so; it should always be true unless the list above was
	// incorrectly generated.
	for _, id := range runIDs {
		key := datastore.IDKey("TestRun", id, nil)
		var run shared.TestRun
		_, err = client.RunInTransaction(ctx, func(tx *datastore.Transaction) error {
			err := tx.Get(key, &run)
			if err != nil {
				return err
			}
			if condition(&run) {
				return operation(tx, key, &run)
			}
			return conditionUnsatisfied{}
		})
		if err != nil {
			_, ok := err.(conditionUnsatisfied)
			if !ok {
				panic(err)
			} else {
				continue
			}
		}
		fmt.Printf("Processed %s (%s %s)\n", key.String(), run.BrowserName, run.BrowserVersion)
	}
}
